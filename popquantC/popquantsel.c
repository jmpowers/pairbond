// fixed perturbation from Maria 9/30/16 with JP batch code added in// from "pop+quant gen trial w-modifiers take 3.nb" <needs to be updated to take 6// NOTE - follow-up projects are planned from these programs so I would appreciate it as a courtesy if you contacted me about a follow-up project of your own before using these in a publication.// Maria R. Servedio & John Powers// June 5 2016 - optimize zbars with B2 =0 before real run#include "stdio.h"#include "math.h"#include "stdlib.h"#include "float.h"#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>#define NLOCI 	2		// number of loci#define GENO 	4		// number of genotypes#define L 		GENO+1	// length of arrays#define EPS 	1.e-14	// machine precision#define VARIABLE1 cf  	// y-axis#define VARIABLE2 alpha  	// x-axis#define MAXINC 	41		// maximum number of increments on each axisFILE *data1, *data2, *data3, *data4, *data7, *data8, *data9, *params;// Function declarationsvoid getInfo();void initialize();void fecundity();void segregation();void death();void divorce();void mating();void selection();void recursions();void alleles();void SetRecTable();void zygoteGenotypes(unsigned int i, unsigned int j, unsigned char mask, unsigned char *zyg);double recProb(int mask, int nLoci);int getBit(int i, int integer);int power(int base, int n);void gotoNewLine();void perturbation();void printTable(long double table[L][L]);void printList(long double list[L]);// Variableslong double Nindivtot;				// population sizelong double Nunittot;				// number of mated pairs + number of singleslong double M[L][L];				// frequency of each type of mated pairlong double xf[L], xm[L];			// frequencies of males and female singleslong double NN[L][L];				// number of each type of mated pairlong double nf[L], nm[L];			// number of male and female singleslong double zbar, zbars;			// mean clutch size, starting valuelong double zbartable[MAXINC][MAXINC];	// NEW optimum zbar's (B2=0) across parameter rangeslong double Nsurv[L][L];			// number of surviving mated pairslong double nsurvf[L], nsurvm[L];	// number of surviving singleslong double	nwf[L][L], nwm[L][L];	// NEW widowed singles for each type of pairlong double mfec[L][L];				// number of fledged offspring from each type of pairlong double noff[L];				// number of fledged offpsring of each genotypelong double ndf[L][L], ndm[L][L];	// NEW divorced singles for each type of pairlong double Nrmp[L][L];				// number of remaining mated pairs after divorcelong double ntotf[L], ntotm[L];		// total singles (sum of all remaining & newly generated singles)long double Nnc[L][L];				// number of new coupleslong double Nt1[L][L];				// number of mated pairs in the next yearlong double Mt1[L][L];				// frequencies of mated pairs in the next yearlong double nft1[L], nmt1[L];		// number of male and female singles in the next yearlong double xft1[L], xmt1[L];		// frequencies of male and female singles in the next yearlong double Nindivtott1;			// population size in the next yearlong double Nunittott1;				// number of mated pairs + number of singles in the next yearlong double Sfpair[L][L],Smpair[L][L];			// NEW selection differentials for mated females and maleslong double zbarselfpair[L][L],zbarselmpair[L][L];		// NEW zbar sel ____long double Sf, Sm;					// overall selection differentialslong double sm, sf;					// proportion surviving through the yearlong double lambda;					// multiplicative rate of increaselong double Tf, Tm, T;				// average generation time for both sexes and overalllong double deltazbar, zbart1;		// change in mean clutch size for the year, mean clutch size in the next yearlong double	A2, B2;					// average allele frequencies not adjusted for sex ratiolong double	A2s, B2s, B2s_tmp;		// starting valueslong double diseq;					// linkage disequilibriumlong double Nindivf, Nindivm;		// total number oof each sex at the start of the generationlong double alleletot;				// sum of all alleleslong double sexrat;					// total proportion of indivs that are femalelong double recTable[L][L][L];		// recombination arrayint y[17][4] = {0,0,				// matrix for recombination matrix (nonsense row)				1,1,				// genotypes to compare  x[1] = A1B1				1,2,				//					    x[2] = A1B2		B2 = increased signal				2,1,				//						x[3] = A2B1		A2 = increased response				2,2};				//						x[4] = A2B2int bothlow; 						//	have A2 and B2 been simulaneously < 0.2?int cycles;							//  number of cycles  in the run - when A2 and B2 are simulaneously < 0.2 and then simultaneously >0.8long double pert;					//  perturbation of B2 when it seems to be fixed with A2 lowint pertc;							//  pertc makes sure the perturbation happens only once// Parameterslong double o, h2;					// standard deviaton of clutch size z (variance is o^2), hertability for clutch sizelong double cf, cm;					// survival cost of offspring production+rearing for each sexlong double dsm, df, dm, dA2;		// selective death rate for displaying males, non-selective death rate for males and femaleslong double dsmCoef[L] = {0};		// matrix of dsm when males displaylong double dA2Coef[L] = {0};		// matrix of dA2 when females respondlong double alpha;					// shift in clutch size due to female responselong double aCoef[L][L] = {{0}};	// matrix of alphas when females respond to a displaying male, zeros elsewherelong double r[NLOCI];				// recombination ratelong double a, b, v;				// density dependence within the brood on offspring survival, population-level density dependence on offspring survival, divorce rateint numgen, printgen;				// number of years to run the program, how often to printint optrun;							// 1: calculate optimal zbar, 2: use optima as initial valuesint var1, var2;  					// counters for the plotting array and the increment numberint INC1, INC2;						// down and across on the plotlong double RANGE1, RANGE2;			// range for VARIABLE1 and VARIABLE2int pertq;							// set to 0 if you want no perturbation, 1 if you want a perturbation (for when b2 = 1 with A2 low)long double pertamt;				// size of the perturbationint pertgen;						// when to perturblong double optdev;					// Z offset from optimumlong double dA2;					// selection on A2long double sfert;					// int runID;char runIDf[8];char cmd[32];char cwd[1024];int main() {    int i, j, k, gen, run, n;		// counters, number of runs    long double holdv1, holdv2;  	// holders for the variables    int counter1 = 0, counter2 = 0; // to set the variables to 0 the first time through        if((params = fopen("params", "r")) == NULL){ //open the params file        printf("cannot open file params\n");    }        fscanf(params, "%d", &n); gotoNewLine();	//find the number of sets of parameters to be read    getcwd(cwd, sizeof(cwd));        for(run = 0; run < n; run++) {				getInfo();		printf("RUN %d\n",runID);				//interface with the system to make directories and move files: UNIX ONLY! Also requires unix line endings!		chdir(cwd);		sprintf(runIDf,"./%d/",runID);		mkdir(runIDf, 0777);		//sprintf(cmd, "cp -p \'%s\' \'%s\'", "params", runIDf); //copy the  whole params file into the new direcotry		sprintf(cmd, "sed -n \'%d,%dp\' params > %sparams", run*12+2, run*12+13, runIDf); //excise the part of params for this RUN		system(cmd);		chdir(runIDf);				//open files to clear old runs		data1 = fopen("results", "w"); 		fclose(data1);		data2 = fopen("Aplot", "w"); 		fclose(data2);		data3 = fopen("Bplot", "w"); 		fclose(data3);		data4 = fopen("Zplot", "w"); 		fclose(data4);		data7 = fopen("sexratplot", "w");	fclose(data7);		data8 = fopen("lagplot", "w"); 		fclose(data8);		data9 = fopen("Nplot", "w"); 		fclose(data9);                //open files to append data        data1 = fopen("results", "a");        data2 = fopen("Aplot", "a");		fprintf(data2, "{");        data3 = fopen("Bplot", "a");		fprintf(data3, "{");        data4 = fopen("Zplot", "a");		fprintf(data4, "{");        data7 = fopen("sexratplot", "a");	fprintf(data7, "{");        data8 = fopen("lagplot", "a");		fprintf(data8, "{");        data9 = fopen("Nplot", "a");		fprintf(data9, "{");                SetRecTable();                for(optrun = 1; optrun <= 2; optrun++){ //change back to 2!! (done)                        printf("\noptrun %d\n", optrun);            fprintf(data1, "\n########################### Run %d ######################\n", optrun);            if(optrun == 1) {                B2s_tmp = B2s;                B2s = 0;                fprintf(data2, "{");                fprintf(data3, "{");                fprintf(data4, "{");                fprintf(data7, "{");                fprintf(data8, "{");                fprintf(data9, "{");            } else if(optrun == 2) {                B2s = B2s_tmp;                fprintf(data2, ",\n{");                fprintf(data3, ",\n{");                fprintf(data4, ",\n{");                fprintf(data7, ",\n{");                fprintf(data8, ",\n{");                fprintf(data9, ",\n{");            }                        VARIABLE1 = 0;            holdv1 = 0;            for(var1 = 0; var1 < INC1+1; var1++) { // loop the data array for plotting var1                if (counter2 == 0) {                    VARIABLE2 = 0;                    holdv2 = 0;                    counter2 = 1;                } else {                    VARIABLE2 = RANGE2/INC2;                    holdv2 = RANGE2/INC2;                }                fprintf(data2, "{");                fprintf(data3, "{");                fprintf(data4, "{");                fprintf(data7, "{");                fprintf(data8, "{");                fprintf(data9, "{");                for(var2 = 0; var2 < INC2+1; var2++) { // loop the data array for plotting var2                    fprintf(data1, "var1: %Lf\t var2: %Lf\n", VARIABLE1, VARIABLE2);                    fprintf(data1,"gen\tA2\t\tB2\t\tdiseq\t\tzbar\t\tsexrat\n");                                        initialize();                                        printf("var1: %LF\t",VARIABLE1);                    printf("var2: %LF\n",VARIABLE2);                                        for(gen = 0; gen < numgen; gen++)  { // loop for years within a single simulation                                                if(gen == 0)	fprintf(data1, "%d\t%Lf\t%Lf\t\t\t%Lf\t\n" ,gen, A2s, B2s, zbar);                                                fecundity();                                                segregation();                                                death();                                                divorce();                                                mating();                                                selection();                                                //debug output                        if(1==0 && VARIABLE1 == 0.25 && VARIABLE2 == 0 && gen == numgen-1) {                            printf("Nindivtot: %Lf\n",Nindivtot);                            printf("Nunittot: %Lf\n",Nunittot);                            printf("M:\n"); printTable(M);                            printf("xf/m:\n");printList(xf); printList(xm);                            printf("NN:\n");printTable(NN);                            printf("nf/m:\n"); printList(nf); printList(nm);                            printf("zbar: %LF\n",zbar);                            printf("Nsurv:\n"); printTable(Nsurv);                            printf("nsurvf/m:\n"); printList(nsurvf); printList(nsurvm);                            printf("nwf/m:\n"); printTable(nwf); printTable(nwm);                            printf("mfec:\n"); printTable(mfec);                            printf("noff:\n"); printList(noff);                            printf("ndf/m:\n"); printTable(ndf); printTable(ndm);                            printf("Nrmp:\n"); printTable(Nrmp);                            printf("ntotf/m:\n"); printList(ntotf); printList(ntotm);                            printf("Nnc:\n"); printTable(Nnc);                            printf("Nt1:\n"); printTable(Nt1);                            printf("Mt1:\n"); printTable(Mt1);                            printf("nf/mt1:\n"); printList(nft1); printList(nmt1);                            printf("xf/mt1:\n"); printList(xft1); printList(xmt1);                            printf("Nindivtott1: %LF\n",Nindivtott1);                            printf("Nunittott1: %LF\n",Nunittott1);                            printf("zbarself/mpair:\n"); printTable(zbarselfpair); printTable(zbarselmpair);                            printf("Sf: %LF\n",Sf); printf("Sm: %LF\n",Sm);                            printf("sf: %LF\n",sf); printf("sm: %LF\n",sm);                            printf("lambda: %LF\n",lambda);                            printf("Tf: %LF\n",Tf); printf("Tm: %LF\n",Tm); printf("T: %LF\n",T);                            printf("deltazbar: %LF\n",deltazbar); printf("zbart1: %LF\n",zbart1);                            printf("alleletot (prev): %LF\n",alleletot);                            printf("%d\t%Lf\t%Lf\t%Lf\t%Lf\t%Lf\n" ,gen+1, A2, B2, diseq, zbar, sexrat);                        }                                                recursions();                                                alleles();                                                                        if ((A2 < 0.2) && (B2 < 0.2)) bothlow = 1;                        if ((A2 > 0.8) && (B2 > 0.8) && bothlow) {							bothlow = 0;							cycles++;						}                                                if((gen+1)%printgen == 0)	fprintf(data1, "%d\t%Lf\t%Lf\t%Lf\t%Lf\t%Lf\n" ,gen+1, A2, B2, diseq, zbar, sexrat);                                                if(pertq == 1 && optrun == 2 && pertc == 0){                            perturbation();                        }                                            if(pertc == 1 && optrun == 2 && (gen+1)%pertgen == 0) pertc = 0; // this should allow the perturbation every 10000 gens                                                zbartable[var1][var2] = zbar-optdev;                                            }                    fprintf(data2,"%Lf", A2);                    fprintf(data3,"%Lf", B2);                    fprintf(data4,"%Lf", zbar);                    fprintf(data7,"%Lf", sexrat);                    fprintf(data8,"%d", cycles);                    fprintf(data9,"%Lf", Nindivtot);                    if (var2<INC2) {                        fprintf(data2,",");                        fprintf(data3,",");                        fprintf(data4,",");                        fprintf(data7,",");                        fprintf(data8,",");                        fprintf(data9,",");                    }                    if (counter2 == 1) {                        VARIABLE2 = holdv2 + RANGE2/INC2;                        holdv2 = holdv2 + RANGE2/INC2;                    }                    fprintf(data1, "\n");                }                counter1 = 1;                if (counter1 == 1) {                    VARIABLE1 = holdv1 + RANGE1/INC1;                    holdv1 = holdv1 + RANGE1/INC1;                    counter2 = 0;                }                fprintf(data2, "}");                fprintf(data3, "}");                fprintf(data4, "}");                fprintf(data7, "}");                fprintf(data8, "}");                fprintf(data9, "}");                if (var1<INC1) {                    fprintf(data2,",");                    fprintf(data3,",");                    fprintf(data4,",");                    fprintf(data7,",");                    fprintf(data8,",");                    fprintf(data9,",");                }            }            fprintf(data2, "}");            fprintf(data3, "}");            fprintf(data4, "}");            fprintf(data7, "}");            fprintf(data8, "}");            fprintf(data9, "}");        }    fprintf(data2, "}");    fprintf(data3, "}");    fprintf(data4, "}");    fprintf(data7, "}");    fprintf(data8, "}");    fprintf(data9, "}");    fclose(data1);    fclose(data2);    fclose(data3);    fclose(data4);    fclose(data7);    fclose(data8);    fclose(data9);    }    fclose(params);    printf("\nDone with all runs.\a");}//////////////////////////////////////////////////////////////////// read parameters from filevoid getInfo() {    //get genotypes    fscanf(params, "%Lf", &A2s);    fscanf(params, "%Lf", &B2s);	gotoNewLine();        //get parameter values    fscanf(params, "%Lf", &zbars);    fscanf(params, "%Lf", &o);    fscanf(params, "%Lf", &h2);		gotoNewLine();    fscanf(params, "%Lf", &cf);    fscanf(params, "%Lf", &cm);		gotoNewLine();    fscanf(params, "%Lf", &dsm);    fscanf(params, "%Lf", &df);    fscanf(params, "%Lf", &dm);    fscanf(params, "%Lf", &alpha);	gotoNewLine();    fscanf(params, "%Lf", &r[0]);    fscanf(params, "%Lf", &r[1]);   gotoNewLine();    fscanf(params, "%Lf", &a);    fscanf(params, "%Lf", &b);    fscanf(params, "%Lf", &v); 		gotoNewLine();        //printing information    fscanf(params, "%d", &numgen);    fscanf(params, "%d", &printgen); gotoNewLine();        fscanf(params, "%Lf", &RANGE1);    fscanf(params, "%Lf", &RANGE2); gotoNewLine();    fscanf(params, "%d", &INC1);    fscanf(params, "%d", &INC2);	gotoNewLine();    fscanf(params, "%d", &runID);	gotoNewLine();    fscanf(params, "%d", &pertq);    fscanf(params, "%Lf", &pertamt);    fscanf(params, "%d", &pertgen);	gotoNewLine();    fscanf(params, "%Lf", &optdev);    fscanf(params, "%Lf", &dA2);    fscanf(params, "%Lf", &sfert);	gotoNewLine();    printf("Nindivtot: %Lf\n",Nindivtot);}//////////////////////////////////////////////////////////////////// initialize numbers and frequenciesvoid initialize() {    //set the starting frequencies in linkage equlibrium    long double x[L] = {0,        (1-A2s)*(1-B2s),        (1-A2s)*B2s,        A2s*(1-B2s),        A2s*B2s };    //starts 1% of indivs as singles and the rest as mated pairs    int i, j;    if(optrun == 1) {        zbar = zbars;    } else { //set the initial optimum zbars individually for each parameter combination        zbar = zbartable[var1][var2];    }    bothlow = 0;    cycles = 0;    pertc = 1;    Nindivtot = 1000;    dA2 = dA2;    for(i = 1; i < L; i++) {        nf[i] = 0.01*(1/2.0)*x[i]*Nindivtot;        nm[i] = 0.01*(1/2.0)*x[i]*Nindivtot;        xf[i] = nf[i]/Nindivtot;        xm[i] = nm[i]/Nindivtot;        if(i == 2 || i == 4) dsmCoef[i] = dsm;        if(i == 3 || i == 4) dA2Coef[i] = dA2;        for(j = 1; j < L; j++){            NN[i][j] = 0.99*x[i]*x[j]*Nindivtot;            M[i][j]= NN[i][j]/Nindivtot;            if ((i > 2) && (j == 2 || j == 4)) aCoef[i][j] = alpha;        }    }}//////////////////////////////////////////////////////////////////// fecundity selection and offspring productionvoid fecundity() {    int i, j;    for(i = 1; i < L; i++) {        for(j = 1; j < L; j++) {            mfec[i][j] = exp(-b*Nindivtot-a*zbar+(pow(a,2)*pow(o,2))/2-a*aCoef[i][j])*(zbar-a*pow(o,2)+aCoef[i][j])*NN[i][j];            if(j==2 || j==4) {				mfec[i][j] = mfec[i][j] * (1-sfert);			}        }    }}//////////////////////////////////////////////////////////////////// segregation//	   relative number of offspring from the mating table, in terms of numbers//	   These are the same in males and females, the factors of 1/2 are thus included in order to account for two sexesvoid segregation() {    int i,j,k;    for(i = 1; i < L; i++) {        noff[i] = 0;    }    //multiplies the recombination matrix with a vector of mating numbers to get a vector of genotype numbers after recombination and segregation    for(i = 1; i < L; i++) {        for(j = 1; j < L; j++) {            for(k = 1; k < L; k++) {                noff[k] += (1/2.0) * recTable[i][j][k] * mfec[i][j];            }        }    }}//////////////////////////////////////////////////////////////////// death//	   produces surviving singles, widowed singles, and surviving mated pairsvoid death() {    int i, j;    long double Mf[L] = {0}, Mm[L] = {0};    for (i = 1; i < L; i++) {        // non-selective death for singles - produces surviving singles        nsurvf[i] = (1 - df)*(1+dA2Coef[i])*nf[i];        nsurvm[i] = (1 - dm)*(1+dA2Coef[i])*nm[i];        for (j = 1; j < L; j++) {            //  selective and non-selective death for mated pairs - produces surviving mated pairs and widowed singles            Nsurv[i][j] = (1-df)*(1-dm)*exp((1/2.0)*(cf+cm)*(-2*zbar+(cf+cm)*pow(o,2)-2*aCoef[i][j]))*(1-dsmCoef[j])*(1+dA2Coef[i])*(1+dA2Coef[j])*NN[i][j];            nwf[i][j] = (-1+df)*exp(-cf*zbar-cm*zbar+(pow(cf,2)*pow(o,2))/2-(cf+cm)*aCoef[i][j])*(1+dA2Coef[i])*(exp((1/2.0)*cm*(2*cf+cm)*pow(o,2))-dm*exp((1/2.0)*cm*(2*cf+cm)*pow(o,2))-exp(cm*(zbar+aCoef[i][j]))+(-1+dm)*exp((1/2.0)*cm*(2*cf+cm)*pow(o,2))*dA2Coef[j]*(-1+dsmCoef[j])+(-1+dm)*exp((1/2.0)*cm*(2*cf+cm)*pow(o,2))*dsmCoef[j])*NN[i][j];            Mf[i] += M[i][j];        }    }    for (j = 1; j < L; j++) {        for (i = 1; i < L; i++) {            nwm[i][j] = (-1+dm)*exp(-(pow(zbar+aCoef[i][j],2)/(2*pow(o,2))))*(exp(pow(zbar-cm*pow(o,2)+aCoef[i][j],2)/(2*pow(o,2)))+(-1+df)*exp(pow(zbar-(cf+cm)*pow(o,2)+aCoef[i][j],2)/(2*pow(o,2)))+(-1+df)*exp(pow(zbar-(cf+cm)*pow(o,2)+aCoef[i][j],2)/(2*pow(o,2)))*dA2Coef[i])*(1+dA2Coef[j])*(-1+dsmCoef[j])*NN[i][j];            Mm[j] += M[i][j];        }    }}//////////////////////////////////////////////////////////////////// divorce//   produces divorced singles and remaining mated pairsvoid divorce() {    // When divorce occurs, 1 mated pair is split into 1 male and 1 female.  This doubles the numbers of counted objects    int i, j;    long double Nsurvf, Nsurvm;    for (i = 1; i < L; i++) {        Nsurvf = 0;        for (j = 1; j < L; j++) {            ndf[i][j] = v*Nsurv[i][j];            Nsurvf += Nsurv[i][j];            Nrmp[i][j] = (1 - v) * Nsurv[i][j];        }    }    for (j = 1; j < L; j++) {        Nsurvm = 0;        for (i = 1; i < L; i++) {            ndm[i][j] = v*Nsurv[i][j];            Nsurvm += Nsurv[i][j];        }    }}//////////////////////////////////////////////////////////////////// random mating//	1) calculates total singles//  2) calculates the number of new couples//  3) regenerates the frequencies of mated pairs and unmated singles//  for the last two, must determine which is the more common sex, then use the appropriate set of equationsvoid mating() {    long double allf = 0, allm = 0; 		// total number of each sex at the time of mating    int i, j;    // total singles    for (i = 1; i < L; i++) {        ntotf[i] = noff[i]+nsurvf[i];        for (j = 1; j < L; j++) {            ntotf[i] += nwf[i][j]+ndf[i][j];        }        allf += ntotf[i];    }    for (j = 1; j < L; j++) {        ntotm[j] = noff[j]+nsurvm[j];        for (i = 1; i < L; i++) {            ntotm[j] += nwm[i][j]+ndm[i][j];        }        allm += ntotm[j];    }        // random mating - produces new couples    // first see which sex is more numerous    Nunittott1 = 0; 	Nindivtott1 = 0;    Nindivf = 0;		Nindivm = 0;    lambda = 0;    long double Ntot = 0;    for (i = 1; i < L; i++) {        for (j = 1; j < L; j++) {            //  number of new couples - equal to the number of the less common sex            if (allf >= allm) 	Nnc[i][j] = ntotf[i]*ntotm[j] / allf;            if (allm > allf) 	Nnc[i][j] = ntotf[i]*ntotm[j] / allm;            Nt1[i][j] = Nrmp[i][j] + Nnc[i][j];            Nunittott1 += Nt1[i][j];            Nindivtott1 += 2*Nt1[i][j];            lambda += Nrmp[i][j]+(1/2.0)*mfec[i][j];            Nindivf += NN[i][j];            Nindivm += NN[i][j];            Ntot += Nrmp[i][j];        }        Nindivm += nm[i];        Nindivf += nf[i];    }    sexrat = ((allm + Ntot)/(allf + Ntot));    if (allf >= allm) {        for (i = 1; i < L; i++)        {            nft1[i] = ntotf[i]*(1 - allm/allf);            nmt1[i] = 0;            xmt1[i] = 0;            Nunittott1 += nft1[i];            Nindivtott1 += nft1[i];            lambda += nsurvm[i];            for (j = 1; j < L; j++)  lambda += nwm[i][j] + ndm[i][j];        }        lambda /= Nindivm;        for (i = 1; i < L; i++) xft1[i] = nft1[i]/Nunittott1;    }    if (allm > allf) {        for (i = 1; i < L; i++) {            nmt1[i] = ntotm[i]*(1 - allf/allm);            nft1[i] = 0;            xft1[i] = 0;            Nunittott1 += nmt1[i];            Nindivtott1 += nmt1[i];            lambda += nsurvf[i];            for (j = 1; j < L; j++)  lambda += nwf[i][j] + ndf[i][j];        }        lambda /= Nindivf;        for (i = 1; i < L; i++) xmt1[i] = nmt1[i]/Nunittott1;    }    }/////////////////////////////////////////////////////////////////////////////////// selection differentials and generation timevoid selection() {    int i, j;    Sf = 0; Sm = 0; sf = 0; sm = 0;    long double Sfden, Smden;    Sfden = 0; Smden = 0;        for(i = 1; i < L; i++) {        Sfden += nsurvf[i];        Smden += nsurvm[i];        sf += nsurvf[i];        sm += nsurvm[i];        for(j = 1; j < L; j++) {            zbarselfpair[i][j] = (-2*(-1+df)*exp(b*Nindivtot+a*zbar+(pow(cf,2)*pow(o,2))/2+a*aCoef[i][j])*(zbar-cf*pow(o,2)+aCoef[i][j])+exp(cf*zbar+(pow(a,2)*pow(o,2))/2+cf*aCoef[i][j])*(pow(o,2)+pow(zbar-a*pow(o,2),2)+aCoef[i][j]*(2*zbar-2*a*pow(o,2)+aCoef[i][j])))/(-2*(-1+df)*exp(b*Nindivtot+a*zbar+(pow(cf,2)*pow(o,2))/2+a*aCoef[i][j])+exp(cf*zbar+(pow(a,2)*pow(o,2))/2+cf*aCoef[i][j])*(zbar-a*pow(o,2)+aCoef[i][j]));            zbarselmpair[i][j] = (exp(-(((zbar+aCoef[i][j])*(zbar-2*a*pow(o,2)+aCoef[i][j]))/(2*pow(o,2))))*(2*(-1+dm)*exp((pow(zbar,2)+2*b*Nindivtot*pow(o,2)+pow(cm,2)*pow(o,4)+2*zbar*aCoef[i][j]+pow(aCoef[i][j],2))/(2*pow(o,2)))*(-1+dsmCoef[j])*(zbar-cm*pow(o,2)+aCoef[i][j])+exp(cm*(zbar+aCoef[i][j])+pow(zbar-a*pow(o,2)+aCoef[i][j],2)/(2*pow(o,2)))*(pow(o,2)+pow(zbar-a*pow(o,2),2)+aCoef[i][j]*(2*zbar-2*a*pow(o,2)+aCoef[i][j]))))/(2*(-1+dm)*exp(b*Nindivtot+a*zbar+(pow(cm,2)*pow(o,2))/2+a*aCoef[i][j])*(-1+dsmCoef[j])+exp(cm*zbar+(pow(a,2)*pow(o,2))/2+cm*aCoef[i][j])*(zbar-a*pow(o,2)+aCoef[i][j]));            Sfpair[i][j] = zbarselfpair[i][j]-(zbar+aCoef[i][j]);            Smpair[i][j] = zbarselmpair[i][j]-(zbar+aCoef[i][j]);            Sf += Sfpair[i][j]*(Nrmp[i][j]+ndf[i][j]+nwf[i][j]+(1/2.0)*mfec[i][j]);            Sm += Smpair[i][j]*(Nrmp[i][j]+ndm[i][j]+nwm[i][j]+(1/2.0)*mfec[i][j]);            Sfden += Nrmp[i][j]+ndf[i][j]+nwf[i][j]+(1/2.0)*mfec[i][j];            Smden += Nrmp[i][j]+ndm[i][j]+nwm[i][j]+(1/2.0)*mfec[i][j];            sf += Nrmp[i][j]+nwf[i][j]+ndf[i][j];            sm += Nrmp[i][j]+nwm[i][j]+ndm[i][j];            Mt1[i][j] = Nt1[i][j]/Nunittott1;        }    }    Sf /= Sfden;	Sm /= Smden;    sf /= Nindivf;	sm /= Nindivm;    Tf = 1 + sf/(lambda - sf);    Tm = 1 + sm/(lambda - sm);    T = (Tf + Tm)/2.0;    deltazbar = (h2 / T)*((Sf + Sm)/2.0);    zbart1 = zbar + deltazbar;}/////////////////////////////////////////////////////////////////////////////////// move to the next generationvoid recursions() {    int i, j;    for(i = 1; i < L; i++) {        nf[i] = nft1[i];			nm[i] = nmt1[i];        xf[i] = nft1[i]/Nunittott1;	xm[i] = nmt1[i]/Nunittott1;        for (j = 1; j < L; j++) {            NN[i][j] = Nt1[i][j];            M[i][j] = Mt1[i][j];        }    }    Nindivtot = Nindivtott1;    Nunittot = Nunittott1;    zbar = zbart1;}/////////////////////////////////////////////////////////////////////////////////// alleles// 		puts things in allele frequenciesvoid alleles() {    int i, j;    long double A1B1, A1B2, A2B1, A2B2;  // for calculating disequilibria    alleletot = 0;    for (i = 1; i < L; i++) {        for (j = 1; j < L; j++) {            alleletot += 2 * Mt1[i][j];        }        alleletot += xft1[i] + xmt1[i];    }        A2 = (xft1[3] + xft1[4] + xmt1[3] + xmt1[4] + 2*Mt1[3][3] + Mt1[1][3] + Mt1[2][3] + Mt1[4][3] + Mt1[3][1] + Mt1[3][2] + Mt1[3][4] + 2*Mt1[4][4] + Mt1[1][4] + Mt1[2][4] + Mt1[3][4] + Mt1[4][1] + Mt1[4][2] + Mt1[4][3])/alleletot;    B2 = (xft1[2] + xft1[4] + xmt1[2] + xmt1[4] + 2*Mt1[2][2] + Mt1[2][1] + Mt1[2][3] + Mt1[2][4] + Mt1[1][2] + Mt1[3][2] + Mt1[4][2] + 2*Mt1[4][4] + Mt1[1][4] + Mt1[2][4] + Mt1[3][4] + Mt1[4][1] + Mt1[4][2] + Mt1[4][3])/alleletot;        A1B1 = xft1[1] + xmt1[1] + Mt1[1][1] + (1/2.0)*(Mt1[1][2] + Mt1[1][3] + Mt1[1][4] + Mt1[2][1] + Mt1[3][1] + Mt1[4][1]);    A2B2 = xft1[4] + xmt1[4] + Mt1[4][4] + (1/2.0)*(Mt1[1][4] + Mt1[2][4] + Mt1[3][4] + Mt1[4][1] + Mt1[4][2] + Mt1[4][3]);    A1B2 = xft1[2] + xmt1[2] + Mt1[2][2] + (1/2.0)*(Mt1[2][1] + Mt1[2][3] + Mt1[2][4] + Mt1[1][2] + Mt1[3][2] + Mt1[4][2]);    A2B1 = xft1[3] + xmt1[3] + Mt1[3][3] + (1/2.0)*(Mt1[1][3] + Mt1[2][3] + Mt1[4][3] + Mt1[3][1] + Mt1[3][2] + Mt1[3][4]);        diseq = A1B1*A2B2 - A1B2*A2B1;}//////////////////////////////////////////////////////////////////// From /clutchsize V2 copy/clutchsizeevV2.c// This is supposed to perturb the system away from b2 = 1 if it seems to be up there when A2 is low.  I'm using the criterion of B2 > 0.9999 and A2 < 0.01 (a bit arbitrary but glancing at the sim results probably sufficient//// 7-29-16 I've also added a perturbation if B2 > 0.9999 and A2 > 0.9999.  There's no need to add one if A2 > 0.9999 but B2 < 0.01, since this case is expected to be neutral for A2// 12-19-16 There are a whole host of perturbations now - it’s set to perturb B2 alone when just it’s high, A2 alone when just it’s high, or both when they’re both high — and the same scheme for low frequencies.//// I'm perturbing by pertamt in LE with everything else.//////void perturbation(){    int c1, c3, c4, c5;						//counter    long double xadd;	//sees if the genotypes add up to 1    long double xtemp[9];    long double maletot, femtot, matetot;        //long double C2 = 0; //DNE, not in original        //long double diseqAB = 0; //DNE    //long double diseqBC = 0; //DNE    //long double diseqABC = 0; //DNE    //long double diseqAC = 0; //DNE, not in original        if ((A2 > 0.999) && (B2 > 0.999)) {        pert = pertamt;        B2 = B2 - pert;        A2 = A2 - pert;                        femtot = 0;        maletot = 0;        matetot = 0;                // getting the total frequencies of females, males, and mated pairs to make sure I keep these constant        for(c1=1; c1<5; c1++) femtot = femtot + xf[c1];        for(c3=1; c3<5; c3++) maletot = maletot + xm[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) matetot = matetot + M[c4][c5];        }                xtemp[1] = (1.0 - A2)*(1.0 - B2) + diseq;        xtemp[2] = (1.0 - A2)*B2 - diseq;        xtemp[3] = A2*(1.0 - B2) - diseq;        xtemp[4] = A2*B2 + diseq;                for(c1=1; c1<5; c1++) xf[c1] = femtot*xtemp[c1];        for(c3=1; c3<5; c3++) xm[c3] = maletot*xtemp[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) M[c4][c5] = matetot*xtemp[c4]*xtemp[c5];        }                        //testing for errors        xadd = 0;        for(c1=1; c1<5; c1++)        {            for(c3=1; c3<5; c3++) xadd = xadd + M[c1][c3];            xadd = xadd + xm[c1] + xf[c1];        }        if(xadd - 1 > 1E-18) printf("Error in perturbation: %Lg\n",xadd - 1);                for(c1=1; c1<5; c1++){            nf[c1] = xf[c1]*Nunittot;            nm[c1] = xm[c1]*Nunittot;            for(c4=1; c4<5; c4++){                NN[c1][c4] = M[c1][c4]*Nunittot;            }        }        pertc = 1;            }                if ((A2 <= 0.999) && (B2 > 0.999)) {        pert = pertamt;        B2 = B2 - pert;                        femtot = 0;        maletot = 0;        matetot = 0;                // getting the total frequencies of females, males, and mated pairs to make sure I keep these constant        for(c1=1; c1<5; c1++) femtot = femtot + xf[c1];        for(c3=1; c3<5; c3++) maletot = maletot + xm[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) matetot = matetot + M[c4][c5];        }                xtemp[1] = (1.0 - A2)*(1.0 - B2) + diseq;        xtemp[2] = (1.0 - A2)*B2 - diseq;        xtemp[3] = A2*(1.0 - B2) - diseq;        xtemp[4] = A2*B2 + diseq;                for(c1=1; c1<5; c1++) xf[c1] = femtot*xtemp[c1];        for(c3=1; c3<5; c3++) xm[c3] = maletot*xtemp[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) M[c4][c5] = matetot*xtemp[c4]*xtemp[c5];        }                        //testing for errors        xadd = 0;        for(c1=1; c1<5; c1++)        {            for(c3=1; c3<5; c3++) xadd = xadd + M[c1][c3];            xadd = xadd + xm[c1] + xf[c1];        }        if(xadd - 1 > 1E-18) printf("Error in perturbation: %Lg\n",xadd - 1);                for(c1=1; c1<5; c1++){            nf[c1] = xf[c1]*Nunittot;            nm[c1] = xm[c1]*Nunittot;            for(c4=1; c4<5; c4++){                NN[c1][c4] = M[c1][c4]*Nunittot;            }        }        pertc = 1;            }            if ((A2 > 0.999) && (B2 <= 0.999)) {        pert = pertamt;        A2 = A2 - pert;                        femtot = 0;        maletot = 0;        matetot = 0;                // getting the total frequencies of females, males, and mated pairs to make sure I keep these constant        for(c1=1; c1<5; c1++) femtot = femtot + xf[c1];        for(c3=1; c3<5; c3++) maletot = maletot + xm[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) matetot = matetot + M[c4][c5];        }                xtemp[1] = (1.0 - A2)*(1.0 - B2) + diseq;        xtemp[2] = (1.0 - A2)*B2 - diseq;        xtemp[3] = A2*(1.0 - B2) - diseq;        xtemp[4] = A2*B2 + diseq;                for(c1=1; c1<5; c1++) xf[c1] = femtot*xtemp[c1];        for(c3=1; c3<5; c3++) xm[c3] = maletot*xtemp[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) M[c4][c5] = matetot*xtemp[c4]*xtemp[c5];        }                        //testing for errors        xadd = 0;        for(c1=1; c1<5; c1++)        {            for(c3=1; c3<5; c3++) xadd = xadd + M[c1][c3];            xadd = xadd + xm[c1] + xf[c1];        }        if(xadd - 1 > 1E-18) printf("Error in perturbation: %Lg\n",xadd - 1);                for(c1=1; c1<5; c1++){            nf[c1] = xf[c1]*Nunittot;            nm[c1] = xm[c1]*Nunittot;            for(c4=1; c4<5; c4++){                NN[c1][c4] = M[c1][c4]*Nunittot;            }        }        pertc = 1;            }            if ((A2 < 0.001) && (B2 < 0.001)) {        pert = pertamt;        B2 = B2 + pert;        A2 = A2 + pert;                        femtot = 0;        maletot = 0;        matetot = 0;                // getting the total frequencies of females, males, and mated pairs to make sure I keep these constant        for(c1=1; c1<5; c1++) femtot = femtot + xf[c1];        for(c3=1; c3<5; c3++) maletot = maletot + xm[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) matetot = matetot + M[c4][c5];        }                xtemp[1] = (1.0 - A2)*(1.0 - B2) + diseq;        xtemp[2] = (1.0 - A2)*B2 - diseq;        xtemp[3] = A2*(1.0 - B2) - diseq;        xtemp[4] = A2*B2 + diseq;                for(c1=1; c1<5; c1++) xf[c1] = femtot*xtemp[c1];        for(c3=1; c3<5; c3++) xm[c3] = maletot*xtemp[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) M[c4][c5] = matetot*xtemp[c4]*xtemp[c5];        }                        //testing for errors        xadd = 0;        for(c1=1; c1<5; c1++)        {            for(c3=1; c3<5; c3++) xadd = xadd + M[c1][c3];            xadd = xadd + xm[c1] + xf[c1];        }        if(xadd - 1 > 1E-18) printf("Error in perturbation: %Lg\n",xadd - 1);                for(c1=1; c1<5; c1++){            nf[c1] = xf[c1]*Nunittot;            nm[c1] = xm[c1]*Nunittot;            for(c4=1; c4<5; c4++){                NN[c1][c4] = M[c1][c4]*Nunittot;            }        }        pertc = 1;            }        if ((A2 >= 0.001) && (B2 < 0.001)) {        pert = pertamt;        B2 = B2 + pert;                        femtot = 0;        maletot = 0;        matetot = 0;                // getting the total frequencies of females, males, and mated pairs to make sure I keep these constant        for(c1=1; c1<5; c1++) femtot = femtot + xf[c1];        for(c3=1; c3<5; c3++) maletot = maletot + xm[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) matetot = matetot + M[c4][c5];        }                xtemp[1] = (1.0 - A2)*(1.0 - B2) + diseq;        xtemp[2] = (1.0 - A2)*B2 - diseq;        xtemp[3] = A2*(1.0 - B2) - diseq;        xtemp[4] = A2*B2 + diseq;                for(c1=1; c1<5; c1++) xf[c1] = femtot*xtemp[c1];        for(c3=1; c3<5; c3++) xm[c3] = maletot*xtemp[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) M[c4][c5] = matetot*xtemp[c4]*xtemp[c5];        }                        //testing for errors        xadd = 0;        for(c1=1; c1<5; c1++)        {            for(c3=1; c3<5; c3++) xadd = xadd + M[c1][c3];            xadd = xadd + xm[c1] + xf[c1];        }        if(xadd - 1 > 1E-18) printf("Error in perturbation: %Lg\n",xadd - 1);                for(c1=1; c1<5; c1++){            nf[c1] = xf[c1]*Nunittot;            nm[c1] = xm[c1]*Nunittot;            for(c4=1; c4<5; c4++){                NN[c1][c4] = M[c1][c4]*Nunittot;            }        }        pertc = 1;            }        if ((A2 < 0.0001) && (B2 >= 0.001)) {        pert = pertamt;        A2 = A2 + pert;                femtot = 0;        maletot = 0;        matetot = 0;                // getting the total frequencies of females, males, and mated pairs to make sure I keep these constant        for(c1=1; c1<5; c1++) femtot = femtot + xf[c1];        for(c3=1; c3<5; c3++) maletot = maletot + xm[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) matetot = matetot + M[c4][c5];        }                xtemp[1] = (1.0 - A2)*(1.0 - B2) + diseq;        xtemp[2] = (1.0 - A2)*B2 - diseq;        xtemp[3] = A2*(1.0 - B2) - diseq;        xtemp[4] = A2*B2 + diseq;                for(c1=1; c1<5; c1++) xf[c1] = femtot*xtemp[c1];        for(c3=1; c3<5; c3++) xm[c3] = maletot*xtemp[c3];        for(c4=1; c4<5; c4++)        {            for(c5=1; c5<5; c5++) M[c4][c5] = matetot*xtemp[c4]*xtemp[c5];        }                        //testing for errors        xadd = 0;        for(c1=1; c1<5; c1++)        {            for(c3=1; c3<5; c3++) xadd = xadd + M[c1][c3];            xadd = xadd + xm[c1] + xf[c1];        }        if(xadd - 1 > 1E-18) printf("Error in perturbation: %Lg\n",xadd - 1);                for(c1=1; c1<5; c1++){            nf[c1] = xf[c1]*Nunittot;            nm[c1] = xm[c1]*Nunittot;            for(c4=1; c4<5; c4++){                NN[c1][c4] = M[c1][c4]*Nunittot;            }        }                pertc = 1;            }    }//////////////////////////////////////////////////////////////////////////////////// SetRecTable// 		This 3 dimensional array sets up the recombination table of probabilities of//		the production of zygote genotypes given the parental genotypes.//			recTable[mom's genotype][dad's genotype][zygote's genotype]void SetRecTable() {    unsigned int i, j, k;    unsigned char mask;    unsigned char zygote[4];    unsigned char *zyg;    int maskLim;    double prob, zygoteProb;        zyg = &zygote[0];    maskLim = pow(2, NLOCI - 1);        //initializing recombination array    for(i = 1; i < L; i++)        for(j = 1; j < L; j++)            for(k = 1; k < L; k++) recTable[i][j][k]=0;        for(i = 0; i < GENO; i++) {        for(j = 0; j < GENO; j++) {            for(mask = 0; mask < maskLim; mask++) {                prob = recProb(mask, NLOCI);                zygoteProb = prob/2.0;                zygoteGenotypes(i, j, mask, zyg);                recTable[i+1][j+1][zygote[0]+1] += zygoteProb;                recTable[i+1][j+1][zygote[1]+1] += zygoteProb;            }        }    }        /*//to check - take out when I'm sure it works!     double tabsum[L][L] = {{0}};     for(i = 1; i < L; i++) {     for(j = 1; j < L; j++) {     for(k = 1; k < L; k++) {     tabsum[i][j] += recTable[i][j][k];     }     if(fabs(tabsum[i][j] - 1) > EPS) {     printf("WARNING!!!  the sum of the mom %d and dad %d does not equal one!\n"     "it equals %le\n", i, j, tabsum[i][j]);     }     }     }*/}//////////////////////////////////////////////////////////////////////////////////// zygoteGenotypes// 		forms the 2 zygote genotypes resulting from a Mom, a Dad & particular recombination maskvoid zygoteGenotypes(unsigned int i, unsigned int j, unsigned char mask, unsigned char *zyg) {    unsigned char zyg1 = 0, zyg2 = 0;    unsigned char bit[NLOCI];    int k;    int powk;    //preliminaries    for(k = 0; k < NLOCI; k++) {        powk = power(2,k);        bit[k] = mask & powk;    }    for(k = 0; k < NLOCI; k++) {        powk = power(2,k);        //gets two zygotes        if(bit[k] == 0) {            zyg1 = zyg1 | (i & powk);            zyg2 = zyg2 | (j & powk);        } else  {            zyg1 = zyg1 | (j & powk);            zyg2 = zyg2 | (i & powk);        }    }    //creates the zygotes    *zyg = zyg1;    zyg++;    *zyg = zyg2;}//////////////////////////////////////////////////////////////////////////////////// recProb// 		calculates the probability of a given recombination pattern.// 		The pairwise recombination rates r[0],r[1],...,r[nLoci-1] are declared and initialized external to this routine.// 		from Mark Kirkpatrick, II-96.double recProb(int mask, int nLoci) {    double prob = 1;    int i;        for(i = 0; i < nLoci-1; i++){        if(getBit(i,mask) == getBit(i+1,mask))            prob *= (1 - r[i]);        else prob *= r[i];    }    return prob;}//////////////////////////////////////////////////////////////////////////////////// getBit// 		returns the ith bit of integer, i = 0,1,...// 		from Mark Kirkpatrick, II-96.int getBit(int i, int integer) {    return (integer%power(2,i+1)) / power(2,i);}//////////////////////////////////////////////////////////////////////////////////// power// 		From Kernigan & Ritchie, 2nd ed., p. 270int power(int base, int n) {    int p;    for(p = 1; n > 0; --n)        p = p * base;    return p;}////////////////////////////////////////////////////////////////////////////////////from Mark's eigenmadness file "range9.c"void gotoNewLine(void) {    char junk;    do        fscanf(params, "%c", &junk);    while((junk != '\r') && (junk != '\n')); //works for Mac and Unix line endings, not DOS}void printTable(long double table[L][L]) {    int i, j;    for(i = 1; i < L; i++) {        for(j = 1; j < L; j++) {            printf("%Lf\t",table[i][j]);        }        printf("\n");    }    printf("\n");}void printList(long double list[L]) {    int i;    for(i = 1; i < L; i++) {        printf("%Lf\t",list[i]);    }    printf("\n");}